---
title: Authentication
pageTitle: "Server-side Authentication with GraphQL, Javascript & Node.js Tutorial"
description: "Learn best practices for implementing email-password authentication on a GraphQL Server with Javascript, Node.js & Express."
question: What kind of authentication must a GraphQL server implement?
answers: ["Username/password authentication", "Token authentication", "Any kind that uses the 'Authorization' header", "Any kind, there are no requirements regarding authentication"]
correctAnswer: 3
---

### Creating Users

So far you've been working only with the `Link` type, but it's time to include `User` as well so that the app can show who posted a certain link and who voted on it.

You'll need some registered users for this, so start by the mutation for creating them. You already know the process for this, but let's go through each step again:

<Instruction>

**Step 1**: As always, first update the schema to define the new type and mutation.

```graphql(path=".../hackernews-graphql-js/src/schema/index.js")
type Mutation {
    createLink(url: String!, description: String!): Link

    # Note that this mutation could receive the email and password directly
    # as arguments, with no problem. You're just using this "authProvider"
    # instead to mimic the signature generated by Graphcool, which will
    # make it easier to integrate this server implementation later with the 
    # code from the frontend tutorials.
    createUser(name: String!, authProvider: AuthProviderSignupData!): User
}

type User {
    id: ID!
    name: String!
    email: String
}

input AuthProviderSignupData {
    email: AUTH_PROVIDER_EMAIL
}

input AUTH_PROVIDER_EMAIL {
    email: String!
    password: String!
}
```

</Instruction>

<Instruction>

**Step 2**: Create a new MongoDB collection to store user entities.

```js{5-5}(path=".../hackernews-graphql-js/src/mongo-connector.js")
module.exports = async () => {
    const db = await MongoClient.connect(MONGO_URL);
    return {
        Links: db.collection('links'),
        Users: db.collection('users'),
    };
}
```

</Instruction>

<Instruction>

**Step 3**: Add a resolver for the mutation, using MongoDB to store the data.

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Mutation: {
    // Add this block right after the `createLink` mutation resolver.
    createUser: async (root, data, {mongo: {Users}}) => {
    // You need to convert the given arguments into the format for the
    // `User` type, grabbing email and password from the "authProvider".
    const newUser = {
        name: data.name,
        email: data.authProvider.email.email,
        password: data.authProvider.email.password,
    };
    const response = await Users.insert(newUser);
    return Object.assign({id: response.insertedIds[0]}, newUser);
    },
},
```

</Instruction>

<Instruction>

**Step 4**: Restart the server and create a test user with your new mutation. You should see something like this:

![](http://i.imgur.com/5sjrV28.png)

</Instruction>

### Sign in mutation

Now that you have users, how would you sign them in using GraphQL? With a new mutation, of course! Mutations are a way for the client to talk to the server whenever it needs an operation that isn't just about fetching data.

For this first time signing users in through GraphQL you'll be using a simple email/password login method, returning a token that can be used in subsequent requests for authentication.


> Note that this is **NOT** supposed to be a production-ready authentication feature, but just a small functioning prototype showing the basics. In a real app you should make sure to properly encrypt passwords before passing them around, and use a good token generation method, such as [JWT](https://jwt.io/).


Again, the workflow for adding this mutation will be very similar to the ones we've done before:

<Instruction>

**Step 1**: Update the schema with the new mutation's definition.

```graphql(path=".../hackernews-graphql-js/src/schema/index.js")
type Mutation {
    signinUser(email: AUTH_PROVIDER_EMAIL): SigninPayload!
}

type SigninPayload {
    token: String
    user: User
}
```

</Instruction>

<Instruction>

**Step 2**: Add a resolver that fetches the user by the given email, validates the password and returns a token. Also, remember to handle the `_id` field from MongoDB, like you did for `Link`.

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Mutation: {
    // ...

    signinUser: async (root, data, {mongo: {Users}}) => {
        const user = await Users.findOne({email: data.email.email});
        if (data.email.password === user.password) {
          return {token: `token-${user.email}`, user};
        }
      },
    },

    User: {
      // Convert the "_id" field from MongoDB to "id" from the schema.
      id: root => root._id || root.id,
    },
```

</Instruction>

<Instruction>

**Step 3**: Restart the server and try the new `signinUser` mutation with one of your previously registered users:

![](http://i.imgur.com/VknQkQ5.png)

</Instruction>

### Authenticating requests

With the token that the `signinUser` mutation provides, apps can authenticate subsequent requests by passing it via the `Authorization` header. The GraphQL server should be able to get the contents from this header on each request, detect what user it's related to, and pass this information down to the resolvers.

As you've already seen before, the best place to put data shared between resolvers is in the context object. You'll need that object to be different in every request now though, since each one may be from a different user. Thankfully, `apollo-server-express` allows that too.

<Instruction>

You'll just have to change that call to `graphqlExpress` to receive a function instead of a fixed object.

```js{1-1,6-13}(path=".../hackernews-graphql-js/src/index.js")
const {authenticate} = require('./authentication');

const start = async () => {
  // ...

  const buildOptions = async (req, res) => {
    const user = await authenticate(req, mongo.Users);
    return {
      context: {mongo, user}, // This context object is passed to all resolvers.
      schema,
    };
  };
  app.use('/graphql', bodyParser.json(), graphqlExpress(buildOptions));

  // ...
}
```

</Instruction>

This `authenticate` function is the one that will do the actual request verification and return the currently authenticated user (if any).

<Instruction>

Create a new file at `src/authentication.js` for it with the following content:

```js(path=".../hackernews-graphql-js/src/authentication.js")
const HEADER_REGEX = /bearer token-(.*)$/;

/**
 * This is an extremely simple token. In real applications make
 * sure to use a better one, such as JWT (https://jwt.io/).
 */
module.exports.authenticate = async ({headers: {authorization}}, Users) => {
  const email = authorization && HEADER_REGEX.exec(authorization)[1];
  return email && await Users.findOne({email});
}
```

</Instruction>

It's pretty straightforward, since the generated token is so simple. Like was said before, make sure to check out different web tokens out there when building a real world application though, such as [JWT](https://jwt.io/).

### Linking User to created links

Your server can now detect the user that triggered each GraphQL request. This could be useful in many situations. For example, the authenticated user should be exactly the one that posted a link being created with the `createLink` mutation. You can now store this information for each link.

To do that, you'll just need to:

<Instruction>

**Step 1**:  Update the schema for `Link` to include the user that posted it.

```graphql(path=".../hackernews-graphql-js/src/schema/index.js")
type Link {
    id: ID!
    url: String!
    description: String!
    postedBy: User
}
```

</Instruction>

<Instruction>

**Step 2**: Change the resolver for `createLink` to store the user id together with new links.

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Mutation: {
    createLink: async (root, data, {mongo: {Links}, user}) => {
        const newLink = Object.assign({postedById: user && user._id}, data)
        const response = await Links.insert(newLink);
        return Object.assign({id: response.insertedIds[0]}, newLink);
    },
},
```

</Instruction>

<Instruction>

**Step 3**: Add a resolver for the `postedBy` field inside `Link `to fetch and return the right user information given the `postedById` retrieved from MongoDB. You could instead do this fetching directly inside the `allLinks` query, looping through the array of items to handle each one, but this approach is a bit cleaner, besides automatically working for any other future queries you may have that also need to fetch link data. Another advantage of having a separate resolver is that it won't even get triggered unless the GraphQL request actually asked for the `postedBy` field, without you having to do any extra checks to avoid fetching useless data. This is what it should look like:

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Link: {
    id: root => root._id || root.id,

    postedBy: async ({postedById}, data, {mongo: {Users}}) => {
        return await Users.findOne({_id: postedById});
    },
},
```

</Instruction>

Done! Unfortunately, if you try restarting your server and creating new links they will still be stored as if posted anonymously, like this:
![](http://i.imgur.com/iObKYMi.png)
That's because nothing is being passed in the `Authorization` header for the requests built by GraphiQL, since it doesn't really know about the authentication method being used. Thankfully, you can configure it so that this is testable as well, which is what will be done next.

### Configuring GraphiQL headers

You will now configure GraphiQL to pass a user's sign in token in the `Authorization` header for each request. 
For that, follow these simple steps:

<Instruction>

**Step 1**: First, choose a previously created user to act as the one logged in, or even create a new one just for this.

![](http://i.imgur.com/dlfNseV.png)

</Instruction>

<Instruction>

**Step 2**: Call the `signinUser` mutation to grab the token to be passed with the requests.

![](http://i.imgur.com/jl5kC9U.png)

</Instruction>

<Instruction>

**Step 3**: Now for the actual code. All you have to do is to set a new option called `passHeader` for that `graphiqlExpress` call, with the proper `Authorization` header for that user.

```js{3-3}(path=".../hackernews-graphql-js/src/index.js")
app.use('/graphiql', graphiqlExpress({
    endpointURL: '/graphql',
    passHeader: `'Authorization': 'bearer token-foo@bar.com'`,
}));
```

</Instruction>

<Instruction>

**Step 4**: Try restarting the server, refreshing GraphiQL and creating a new link now. You should see that `postedBy` will have your chosen user's information.

![](https://i.imgur.com/WAH9DKw.png)

</Instruction>
